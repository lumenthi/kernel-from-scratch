.PHONY : all clean fclean re run docker

HOSTAC = nasm
# -f: format
HOSTACFLAGS = -f elf32

HOSTCC = gcc
# -m32: for 32 bits kernel
# -ffreestanding: no _start symbol
# -fno-pic: remove __x86.get_pc_thunk.bx function automatically generated by gcc
# -c: compile source files without linking
HOSTCFLAGS = -fno-builtin \
				-fno-exceptions \
				-fno-stack-protector \
				-nostdlib \
				-nodefaultlibs \
				-fno-pic \
				-m32 \
				-ffreestanding \
				-static \
				-c \
				-I$(HEADDIR) -I$(KERNLIBDIR)/headers -I$(KERNLIBDIR)/printk/headers

HOSTLINKER = ld
# -m elf_i386: emulate the elf_i386 linker
# -n: Turn off page alignment of sections, disable linking against shared libraries
HOSTLINKERFLAG = -m elf_i386 \
					-n

# FOLDERS
SRCDIR = sources
OBJDIR = objects
HEADDIR = headers

TARGETDIR = targets
X86TARGETDIR = $(TARGETDIR)/x86
BOOTDIR = boot
ISODIR = iso

###############

# DOCKER
NAME_DOCKER = kfs-build

# LINKER
LINKER = linker.ld

# KERNEL
NAME = kernel.bin
NAME_ISO = kernel.iso
KERNELDIR = kernel

# LIB
KERNLIBDIR = $(SRCDIR)/$(KERNELDIR)/kernlib
KERNLIB = $(KERNLIBDIR)/kernlib.a

KERNEL_SRCS =	kernel.c \
				keyboard.c \
				gdt.c \

KERNEL_HEADS =	kernel.h \
				keyboard.h \

KERNEL_SOURCES = $(addprefix $(SRCDIR)/$(KERNELDIR)/, $(KERNEL_SRCS))
KERNEL_OBJECTS = $(addprefix $(OBJDIR)/$(KERNELDIR)/, $(KERNEL_SRCS:.c=.o))
KERNEL_HEADERS = $(addprefix $(HEADDIR)/, $(KERNEL_HEADS))

# BOOT
GRUBDIR = grub
GRUBCFG = grub.cfg

BOOT_SRCS =	boot.s \
			load_gdt.s \

BOOT_SOURCES = $(addprefix $(SRCDIR)/$(BOOTDIR)/, $(BOOT_SRCS))
BOOT_OBJECTS = $(addprefix $(OBJDIR)/$(BOOTDIR)/, $(BOOT_SRCS:.s=.o))

TODOS=$(shell grep -nr "TODO" $(SRCDIR) $(HEADDIR) | wc -l)

###############

# Count files to compile
SHOULD_COUNT = 1
FILES_TO_COMPILE = 0
ifeq ($(SHOULD_COUNT), 1)
	FILES_TO_COMPILE:=$(shell make -n SHOULD_COUNT=0 | grep "gcc" | wc -l)
endif

###############

# QEMU
QEMU = qemu-system-i386
QEMUFLAGS = -s -S
DEBUG_FILE = debug.tmp

##############

# COLOR CODES
GREEN = '\033[4;32m'
RED = '\033[4;31m'
BLANK = '\033[0m'
YELLOW = '\033[4;33m'
CYAN = '\033[4;38;5;51m'
WARNING = '\033[1;33m'
RESET = '\033[0m'
COMPILE_COLOR = '\033[0;33m'

TICK = '\033[1;32m~\033[0m'
CROSS = '\033[1;31mx\033[0m'

###############

all:
	@ $(MAKE) -s -C $(KERNLIBDIR)
	@ env DOCKER_COMPILE=0 $(MAKE) --no-print-directory $(X86TARGETDIR)/$(NAME_ISO)

$(X86TARGETDIR)/$(NAME_ISO): $(KERNLIB) $(KERNEL_OBJECTS) $(BOOT_OBJECTS)
	@ mkdir -p $(X86TARGETDIR)/$(ISODIR)/$(BOOTDIR)/$(GRUBDIR)
	@ cp $(SRCDIR)/$(BOOTDIR)/$(GRUBCFG) $(X86TARGETDIR)/$(ISODIR)/$(BOOTDIR)/$(GRUBDIR)/
	@ cp $(SRCDIR)/$(LINKER) $(X86TARGETDIR)/$(ISODIR)/

	@ $(HOSTLINKER) $(HOSTLINKERFLAG) -o $(X86TARGETDIR)/$(ISODIR)/$(BOOTDIR)/$(NAME) \
		-T $(X86TARGETDIR)/$(ISODIR)/$(LINKER) $(KERNEL_OBJECTS) \
		$(KERNLIB) $(BOOT_OBJECTS)

ifeq ($(DOCKER_COMPILE), 0)
	grub-mkrescue -o $(X86TARGETDIR)/$(NAME_ISO) $(X86TARGETDIR)/$(ISODIR)
else
	docker build -t $(NAME_DOCKER) .
	docker run --rm --name $(NAME_DOCKER) -d $(NAME_DOCKER)
	docker cp $(NAME_DOCKER):/$(NAME_ISO) $(X86TARGETDIR)/$(NAME_ISO)
	touch $(X86TARGETDIR)/$(NAME_ISO)
	docker kill $(NAME_DOCKER)
endif

	@ printf " %b | Compiled %b%b%b\n" $(TICK) $(GREEN) $(NAME) $(BLANK)

##### KERNEL LIB #####

$(KERNLIB):
	@ $(MAKE) -s -C $(KERNLIBDIR)

##### KERNEL COMPILATION #####

I =  1
$(KERNEL_OBJECTS): $(OBJDIR)/$(KERNELDIR)/%.o: $(SRCDIR)/$(KERNELDIR)/%.c $(KERNEL_HEADERS)
	@ printf "[$(I)/$(FILES_TO_COMPILE)] "
	@ mkdir -p $(OBJDIR)/$(KERNELDIR)
	$(HOSTCC) $(HOSTCFLAGS) -o $@ $<
	$(eval I=$(shell echo $$(($(I) + 1))))

##############################

##### BOOT COMPILATION #####

$(BOOT_OBJECTS): $(OBJDIR)/$(BOOTDIR)/%.o: $(SRCDIR)/$(BOOTDIR)/%.s
	@ mkdir -p $(OBJDIR)/$(BOOTDIR)
	@ $(HOSTAC) $(HOSTACFLAGS) -o $@ $<

############################

clean:
	@ $(MAKE) -s -C $(KERNLIBDIR) clean
	@ test -d $(OBJDIR) && \
	rm -rf $(OBJDIR) && \
	printf " %b | " $(TICK) && \
	printf "Removed %b%b%b folder\n" $(YELLOW) $(OBJDIR) $(BLANK) \
	|| (printf " %b | " $(CROSS) && \
	printf "No %b%b%b folder\n" $(YELLOW) $(OBJDIR) $(BLANK))

fclean: clean
	@ test -f $(KERNLIB) && rm -rf $(KERNLIB) && \
	test -f $(DEBUG_FILE) && \
	rm -rf $(DEBUG_FILE) && \
	printf " %b | " $(TICK) && \
	printf "Removed %b%b%b file\n" $(RED) $(DEBUG_FILE) $(BLANK) \
	|| (printf " %b | " $(CROSS) && \
	printf "No %b%b%b file\n" $(RED) $(DEBUG_FILE) $(BLANK))
	@ test -d $(TARGETDIR) && \
	rm -rf $(TARGETDIR) && \
	printf " %b | " $(TICK) && \
	printf "Removed %b%b%b folder\n" $(RED) $(TARGETDIR) $(BLANK) \
	|| (printf " %b | " $(CROSS) && \
	printf "No %b%b%b folder\n" $(RED) $(TARGETDIR) $(BLANK))

re: fclean all

debug: all
	@ printf "@ Creating %b%b%b file\n" $(YELLOW) $(DEBUG_FILE) $(BLANK)
	@ echo 'set disassembly-flavor intel' > debug.tmp
	@ echo 'target remote localhost:1234' >> debug.tmp
	@ echo 'continue' >> debug.tmp
	@ printf "@ Run %bexec gdb -x %b%b in another window to start debugging\n" $(CYAN) $(DEBUG_FILE) $(BLANK)
	$(QEMU) $(QEMUFLAGS) -cdrom $(X86TARGETDIR)/$(NAME_ISO)

todo:
	@ printf "%b" $(WARNING)
	@ grep -nr "TODO" $(SRCDIR) $(HEADDIR) || true
	@ printf "%b" $(BLANK)

run:
	$(QEMU) -cdrom $(X86TARGETDIR)/$(NAME_ISO)

docker:
	@ $(MAKE) -s -C $(KERNLIBDIR)
	@ env DOCKER_COMPILE=1 $(MAKE) --no-print-directory $(X86TARGETDIR)/$(NAME_ISO)
